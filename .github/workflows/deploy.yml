name: Deploy to VPS

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  NODE_VERSION: '20'
  DEPLOY_USER: clientdash
  DEPLOY_HOST: 49.13.129.43
  DEPLOY_PATH: /home/clientdash/client-dashboard
  PM2_APP_NAME: client-dashboard

jobs:
  # Run tests and build validation
  test:
    name: Test & Lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linter
        run: npm run lint --if-present || echo "No lint script found"

      - name: Run type check
        run: npx tsc --noEmit

      - name: Run tests
        run: npm test -- --coverage --maxWorkers=2
        env:
          CI: true

      - name: Upload coverage to artifacts
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage/
          retention-days: 7

  # Build application
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build frontend and feedback widget
        run: npm run build
        env:
          NODE_ENV: production
          VITE_FIREBASE_API_KEY: ${{ secrets.VITE_FIREBASE_API_KEY }}
          VITE_FIREBASE_AUTH_DOMAIN: ${{ secrets.VITE_FIREBASE_AUTH_DOMAIN }}
          VITE_FIREBASE_DATABASE_URL: ${{ secrets.VITE_FIREBASE_DATABASE_URL }}
          VITE_FIREBASE_PROJECT_ID: ${{ secrets.VITE_FIREBASE_PROJECT_ID }}
          VITE_FIREBASE_STORAGE_BUCKET: ${{ secrets.VITE_FIREBASE_STORAGE_BUCKET }}
          VITE_FIREBASE_MESSAGING_SENDER_ID: ${{ secrets.VITE_FIREBASE_MESSAGING_SENDER_ID }}
          VITE_FIREBASE_APP_ID: ${{ secrets.VITE_FIREBASE_APP_ID }}
          # Bakes the production API URL into the frontend bundle at build time.
          # Without this, socialAuth.ts falls back to localhost:3001 ‚Üí ERR_CONNECTION_REFUSED in prod.
          VITE_API_URL: ${{ secrets.VITE_API_URL }}

      - name: Build API server (TypeScript compilation)
        run: npx tsc -p tsconfig.server.json

      - name: Create deployment package
        run: |
          mkdir -p deploy-package
          cp -r dist deploy-package/
          cp -r dist-server deploy-package/
          cp package.json package-lock.json deploy-package/
          cp ecosystem.config.js deploy-package/
          cp -r firestore.* deploy-package/ || true

          # Create version file
          echo "{\"version\":\"${{ github.sha }}\",\"build_time\":\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",\"branch\":\"${{ github.ref_name }}\"}" > deploy-package/version.json

      - name: Create artifact archive
        run: |
          cd deploy-package
          tar -czf ../deploy-${{ github.sha }}.tar.gz .
          cd ..

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: deploy-package
          path: deploy-${{ github.sha }}.tar.gz
          retention-days: 30

  # Deploy to VPS
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch')
    environment:
      name: production
      url: https://client.samixism.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: deploy-package

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ env.DEPLOY_HOST }} >> ~/.ssh/known_hosts

      - name: Ensure deployment directory structure exists
        run: |
          ssh -i ~/.ssh/deploy_key ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'EOF'
            mkdir -p ${{ env.DEPLOY_PATH }}/{releases,backups,shared,logs}
            echo "‚úÖ Directory structure created/verified"
          EOF

      - name: Create backup on server
        run: |
          ssh -i ~/.ssh/deploy_key ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'EOF'
            if [ -d "${{ env.DEPLOY_PATH }}/current" ]; then
              BACKUP_DIR="${{ env.DEPLOY_PATH }}/backups/$(date +%Y%m%d_%H%M%S)_${{ github.sha }}"
              mkdir -p "$BACKUP_DIR"
              cp -r ${{ env.DEPLOY_PATH }}/current/* "$BACKUP_DIR/" || true
              echo "Backup created at $BACKUP_DIR"

              # Keep only last 5 backups
              cd ${{ env.DEPLOY_PATH }}/backups
              ls -t | tail -n +6 | xargs -r rm -rf
            fi
          EOF

      - name: Upload and extract deployment package
        run: |
          scp -i ~/.ssh/deploy_key deploy-${{ github.sha }}.tar.gz \
            ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }}:${{ env.DEPLOY_PATH }}/releases/

          ssh -i ~/.ssh/deploy_key ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'EOF'
            cd ${{ env.DEPLOY_PATH }}/releases
            mkdir -p ${{ github.sha }}
            tar -xzf deploy-${{ github.sha }}.tar.gz -C ${{ github.sha }}
            rm deploy-${{ github.sha }}.tar.gz
          EOF

      - name: Install production dependencies on server
        run: |
          ssh -i ~/.ssh/deploy_key ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'EOF'
            cd ${{ env.DEPLOY_PATH }}/releases/${{ github.sha }}
            # FIX: Use plain 'npm ci' (not --production) so ALL deps including
            # transitive runtime deps resolve correctly. DevDeps add ~50MB but
            # prevent silent runtime failures from missing packages.
            npm ci
          EOF

      - name: Write environment file from secrets
        run: |
          # Write .env directly from GitHub Secrets ‚Äî no dependency on shared/.env on server.
          # This ensures every deployment has all required env vars, nothing is ever missing.
          ssh -i ~/.ssh/deploy_key ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} "cat > ${{ env.DEPLOY_PATH }}/releases/${{ github.sha }}/.env << 'ENVEOF'
NODE_ENV=production
PORT=3001
ALLOWED_ORIGINS=https://client.samixism.com
RATE_LIMIT_MAX=50

# API Base URL (baked into frontend at build time via vite.config.ts ‚Äî also kept here for reference)
VITE_API_URL=https://client.samixism.com

# Firebase (frontend ‚Äî baked into bundle at build time)
VITE_FIREBASE_API_KEY=${{ secrets.VITE_FIREBASE_API_KEY }}
VITE_FIREBASE_AUTH_DOMAIN=${{ secrets.VITE_FIREBASE_AUTH_DOMAIN }}
VITE_FIREBASE_DATABASE_URL=${{ secrets.VITE_FIREBASE_DATABASE_URL }}
VITE_FIREBASE_PROJECT_ID=${{ secrets.VITE_FIREBASE_PROJECT_ID }}
VITE_FIREBASE_STORAGE_BUCKET=${{ secrets.VITE_FIREBASE_STORAGE_BUCKET }}
VITE_FIREBASE_MESSAGING_SENDER_ID=${{ secrets.VITE_FIREBASE_MESSAGING_SENDER_ID }}
VITE_FIREBASE_APP_ID=${{ secrets.VITE_FIREBASE_APP_ID }}

# Social OAuth credentials (backend ‚Äî used by API server at runtime)
FACEBOOK_CLIENT_ID=${{ secrets.FACEBOOK_CLIENT_ID }}
FACEBOOK_CLIENT_SECRET=${{ secrets.FACEBOOK_CLIENT_SECRET }}
INSTAGRAM_CLIENT_ID=${{ secrets.INSTAGRAM_CLIENT_ID }}
INSTAGRAM_CLIENT_SECRET=${{ secrets.INSTAGRAM_CLIENT_SECRET }}
TWITTER_CLIENT_ID=${{ secrets.TWITTER_CLIENT_ID }}
TWITTER_CLIENT_SECRET=${{ secrets.TWITTER_CLIENT_SECRET }}
LINKEDIN_CLIENT_ID=${{ secrets.LINKEDIN_CLIENT_ID }}
LINKEDIN_CLIENT_SECRET=${{ secrets.LINKEDIN_CLIENT_SECRET }}
TIKTOK_CLIENT_KEY=${{ secrets.TIKTOK_CLIENT_KEY }}
TIKTOK_CLIENT_SECRET=${{ secrets.TIKTOK_CLIENT_SECRET }}
YOUTUBE_CLIENT_ID=${{ secrets.YOUTUBE_CLIENT_ID }}
YOUTUBE_CLIENT_SECRET=${{ secrets.YOUTUBE_CLIENT_SECRET }}

# OAuth redirect URI
SOCIAL_OAUTH_REDIRECT_URI=${{ secrets.SOCIAL_OAUTH_REDIRECT_URI }}

# Novu notifications
NOVU_API_KEY=${{ secrets.NOVU_API_KEY }}
ENVEOF
echo '‚úÖ .env written from GitHub Secrets'"

      - name: Run health check on current version
        id: pre_health
        continue-on-error: true
        run: |
          RESPONSE=$(ssh -i ~/.ssh/deploy_key ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} \
            'curl -s -o /dev/null -w "%{http_code}" http://localhost:3001/health 2>/dev/null || echo "000"')
          echo "pre_health_status=$RESPONSE" >> $GITHUB_OUTPUT
          echo "Pre-deployment health status: $RESPONSE"

      - name: Deploy with PM2 (zero-downtime)
        run: |
          ssh -i ~/.ssh/deploy_key ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'EOF'
            cd ${{ env.DEPLOY_PATH }}/releases/${{ github.sha }}

            # Verify dist-server exists before switching symlink
            if [ ! -d "dist-server/api" ]; then
              echo "‚ùå FATAL: dist-server/api not found in deploy package!"
              echo "    The TypeScript build may have failed."
              ls -la dist-server/ || echo "  (dist-server does not exist)"
              exit 1
            fi

            echo "‚úÖ dist-server/api verified"
            ls -la dist-server/api/

            # Atomically update /dist to point to new release's frontend build.
            # PM2 serve reads /home/clientdash/client-dashboard/dist directly.
            ln -sfn ${{ env.DEPLOY_PATH }}/releases/${{ github.sha }}/dist ${{ env.DEPLOY_PATH }}/dist

            # Update /current to point to new release (API server uses this for dist-server/).
            ln -sfn ${{ env.DEPLOY_PATH }}/releases/${{ github.sha }} ${{ env.DEPLOY_PATH }}/current

            cd ${{ env.DEPLOY_PATH }}/current

            # Reload API server with new code and env. Fallback to start if first deploy.
            pm2 reload ecosystem.config.js --env production --update-env \
              || pm2 start ecosystem.config.js --env production

            # Save the process list so PM2 can resurrect after server reboot
            pm2 save --force

            echo "=== PM2 Status ==="
            pm2 list
          EOF

      - name: Wait for application startup
        # Give PM2 time to bind the port, send the ready signal, and for
        # listen_timeout (10s) + startup time to complete across both instances
        run: sleep 20

      - name: Health check after deployment
        id: post_health
        run: |
          ssh -i ~/.ssh/deploy_key ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'HEALTHEOF'
            echo "=== PM2 Status ==="
            pm2 list

            echo ""
            echo "=== Port 3001 listeners ==="
            netstat -tulpn 2>/dev/null | grep 3001 || ss -tulpn | grep 3001 || echo "Nothing on 3001"

            echo ""
            echo "=== Testing health endpoint ==="
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3001/health 2>/dev/null || echo "000")
            echo "HTTP Status: $HTTP_STATUS"

            if [ "$HTTP_STATUS" = "200" ]; then
              echo "‚úÖ Health check PASSED"
              exit 0
            else
              echo "‚ùå Health check FAILED (status: $HTTP_STATUS)"
              echo ""
              echo "=== Last 30 lines of API error log ==="
              pm2 logs client-dashboard-api --lines 30 --nostream --err || true
              exit 1
            fi
          HEALTHEOF

          echo "health_status=success" >> $GITHUB_OUTPUT

      - name: Rollback on failure
        if: failure() && steps.post_health.outcome == 'failure'
        run: |
          echo "üîÑ Deployment failed ‚Äî initiating automatic rollback..."
          ssh -i ~/.ssh/deploy_key ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'EOF'
            cd ${{ env.DEPLOY_PATH }}/backups
            LATEST_BACKUP=$(ls -t | head -n1)

            if [ -n "$LATEST_BACKUP" ]; then
              echo "Rolling back to: $LATEST_BACKUP"
              BACKUP_PATH="${{ env.DEPLOY_PATH }}/backups/$LATEST_BACKUP"
              ln -sfn "$BACKUP_PATH/dist" ${{ env.DEPLOY_PATH }}/dist
              ln -sfn "$BACKUP_PATH" ${{ env.DEPLOY_PATH }}/current
              cd ${{ env.DEPLOY_PATH }}/current
              pm2 reload ecosystem.config.js --env production --update-env
              pm2 save --force
              echo "‚úÖ Rollback completed"
            else
              echo "‚ùå No backup found for rollback!"
              exit 1
            fi
          EOF
          exit 1

      - name: Cleanup old releases
        if: success()
        run: |
          ssh -i ~/.ssh/deploy_key ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'EOF'
            cd ${{ env.DEPLOY_PATH }}/releases
            # Keep only last 5 releases
            ls -t | tail -n +6 | xargs -r rm -rf
            echo "‚úÖ Old releases cleaned up"
          EOF

      - name: Deployment summary
        if: always()
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Pre-deployment health:** ${{ steps.pre_health.outputs.pre_health_status || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Post-deployment health:** ${{ steps.post_health.outputs.health_status || 'failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY

  # Notify deployment status
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: deploy
    if: always()
    steps:
      - name: Deployment notification
        run: |
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "‚úÖ Deployment to client.samixism.com succeeded"
          else
            echo "‚ùå Deployment to client.samixism.com FAILED ‚Äî check Actions logs"
          fi
